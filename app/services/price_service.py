import json
import logging
from typing import List, Dict
from collections import defaultdict
import html as _html

from app.models import (
    PricePredictionRequest, PricePredictionResponse,
    PlaceBlockVO, TimetableVO,
    DailyCostSummary, TripTotalSummary,
    FoodCostDetail, AccommodationCostDetail, CostRange
)
from app.services.gemini import gemini_model
import time

logger = logging.getLogger("uvicorn.error")

def predict_price_service(request: PricePredictionRequest) -> PricePredictionResponse:
    headcount = request.headcount
    
    # 1. Timetable ID -> Date 매핑 생성 & 날짜 정렬
    # 예: {144: "2025-11-22", 153: "2025-11-23"}
    timetable_map = {t.timetableId: t.date for t in request.timeTables}
    sorted_dates = sorted(list(set(timetable_map.values())))
    
    # 2. 데이터를 날짜별로 그룹화
    # grouped_blocks["2025-11-22"] = [block1, block2...]
    grouped_blocks: Dict[str, List[PlaceBlockVO]] = defaultdict(list)
    
    for block in request.placeBlocks:
        # block의 timeTableId로 날짜를 찾음
        date_str = timetable_map.get(block.timeTableId)
        if date_str:
            grouped_blocks[date_str].append(block)
        else:
            logger.warning(f"Block {block.blockId} has unknown timeTableId {block.timeTableId}")

    # 3. 날짜별 비용 계산
    daily_summaries = []
    
    # 전체 여행 합계 누적용 변수
    grand_food_total = 0
    grand_accom_min = 0
    grand_accom_max = 0

    # map placeName -> description (generated by AI)
    place_desc_map: Dict[str, str] = {}

    for idx, date_str in enumerate(sorted_dates):
        blocks = grouped_blocks.get(date_str, [])
        
        # 날짜별 임시 저장소
        d_foods = []
        d_accoms = []
        d_food_total = 0
        d_accom_min = 0
        d_accom_max = 0
        
        for block in blocks:
            # Generate a short AI description for the place (used in UI)
            desc = _summarize_place(block)
            if desc:
                place_desc_map[block.placeName] = desc

            # 카테고리 2: 식당
            if block.placeCategory == 2:
                res = _estimate_food_price(block, headcount)
                
                # 결과 파싱
                p_person = res.get("estimatedPrice", 15000)
                t_price = p_person * headcount
                
                d_foods.append(FoodCostDetail(
                    placeName=block.placeName,
                    pricePerPerson=p_person,
                    totalPrice=t_price,
                    menuExamples=res.get("menuExamples", []),
                    placeDescription=desc
                ))
                d_food_total += t_price
            
            # 카테고리 1: 숙소
            elif block.placeCategory == 1:
                res = _estimate_accommodation_price(block, headcount)
                
                room_type = res.get("recommendedRoomTypeForHeadcount", "기본 객실")
                room_types = res.get("roomTypes", [])
                selected = next((r for r in room_types if r["type"] == room_type), None)
                
                if not selected and room_types:
                    selected = room_types[0]
                    room_type = selected["type"]
                
                if selected:
                    min_p, max_p = selected["priceRange"][0], selected["priceRange"][1]
                else:
                    min_p, max_p = 50000, 100000 # Fallback

                d_accoms.append(AccommodationCostDetail(
                    placeName=block.placeName,
                    roomType=room_type,
                    priceRange=CostRange(min=min_p, max=max_p),
                    pricePerPerson=CostRange(min=min_p // headcount, max=max_p // headcount)
                    ,
                    placeDescription=desc
                ))
                d_accom_min += min_p
                d_accom_max += max_p

        # 일별 요약 생성
        daily_summary = DailyCostSummary(
            date=date_str,
            dayNumber=idx + 1,
            foodDetails=d_foods,
            accommodationDetails=d_accoms,
            dailyTotalFood=d_food_total,
            dailyTotalAccommodationMin=d_accom_min,
            dailyTotalAccommodationMax=d_accom_max,
            dailyTotalMin=d_food_total + d_accom_min,
            dailyTotalMax=d_food_total + d_accom_max
        )
        daily_summaries.append(daily_summary)

        # 전체 합계 누적
        grand_food_total += d_food_total
        grand_accom_min += d_accom_min
        grand_accom_max += d_accom_max

    # 4. 전체 여행 요약 생성
    trip_summary = TripTotalSummary(
        totalFoodCost=grand_food_total,
        totalAccommodationMin=grand_accom_min,
        totalAccommodationMax=grand_accom_max,
        perPersonCost=CostRange(
            min=(grand_food_total + grand_accom_min) // headcount,
            max=(grand_food_total + grand_accom_max) // headcount
        ),
        groupTotalCost=CostRange(
            min=grand_food_total + grand_accom_min,
            max=grand_food_total + grand_accom_max
        )
    )

    # Build HTML for direct display (frontend can use this HTML instead of raw JSON)
    try:
        rendered = _build_html(daily_summaries, trip_summary, grouped_blocks, place_desc_map)
    except Exception as e:
        logger.error(f"Failed to build HTML render: {e}")
        rendered = None

    return PricePredictionResponse(
        dailyCosts=daily_summaries,
        tripSummary=trip_summary,
        renderHtml=rendered
    )


def _build_html(daily_summaries: List[DailyCostSummary], trip_summary: TripTotalSummary, grouped_blocks: Dict[str, List[PlaceBlockVO]], place_desc_map: Dict[str, str]) -> str:
    """Build a simple, safe HTML string for direct display in the frontend.
    Use minimal inline classes — front can style further if needed.
    """
    def esc(s):
        return _html.escape(str(s)) if s is not None else ''

    parts = []
    parts.append('<div class="price-summary-root">')
    parts.append('<h2 style="margin:0 0 8px 0;font-size:18px">여행 비용 요약</h2>')

    for daily in daily_summaries:
        parts.append(f'<section style="border:1px solid #e5e7eb;padding:12px;border-radius:6px;margin-bottom:12px;background:#fff">')
        parts.append(f'<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">')
        parts.append(f'<div><div style="font-size:13px;color:#6b7280">Day {esc(daily.dayNumber)}</div><div style="font-weight:600">{esc(daily.date)}</div></div>')
        parts.append(f'<div style="font-size:13px;color:#374151">합계: {esc(daily.dailyTotalMin)} ~ {esc(daily.dailyTotalMax)}원</div>')
        parts.append('</div>')

        # places (from grouped_blocks)
        places = grouped_blocks.get(daily.date, []) if grouped_blocks is not None else []
        parts.append('<div style="margin-bottom:8px">')
        parts.append('<div style="font-weight:600;margin-bottom:6px">이 날의 장소</div>')
        if places:
            parts.append('<ul style="margin:0;padding:0;list-style:none;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px">')
            for p in places:
                parts.append('<li style="border:1px solid #e5e7eb;padding:8px;border-radius:6px;background:#f9fafb">')
                parts.append(f'<div style="font-weight:600">{esc(p.placeName)}</div>')
                if getattr(p, 'placeTheme', None):
                    parts.append(f'<div style="font-size:12px;color:#6b7280">테마: {esc(p.placeTheme)}</div>')
                if getattr(p, 'placeAddress', None):
                    parts.append(f'<div style="font-size:12px;color:#6b7280">{esc(p.placeAddress)}</div>')
                if getattr(p, 'placeRating', None) is not None:
                    parts.append(f'<div style="font-size:12px;color:#6b7280">평점: {esc(p.placeRating)}</div>')
                    # show AI-generated description for the place if available
                    pd = place_desc_map.get(p.placeName)
                    if pd:
                        parts.append(f'<div style="margin-top:6px;color:#374151">{esc(pd)}</div>')
                parts.append('</li>')
            parts.append('</ul>')
        else:
            parts.append('<div style="font-size:13px;color:#6b7280">등록된 장소가 없습니다.</div>')
        parts.append('</div>')

        # food details
        parts.append('<div style="margin-bottom:8px">')
        parts.append('<div style="font-weight:600;margin-bottom:6px">식비</div>')
        if daily.foodDetails:
            for f in daily.foodDetails:
                parts.append('<div style="border:1px solid #eef2ff;padding:8px;border-radius:6px;background:#fff">')
                parts.append(f'<div style="font-weight:600">{esc(f.placeName)}</div>')
                parts.append(f'<div style="font-size:12px;color:#6b7280">1인당: {esc(f.pricePerPerson)}원 / 총: {esc(f.totalPrice)}원</div>')
                if getattr(f, 'menuExamples', None):
                    parts.append(f'<div style="font-size:12px;color:#6b7280">메뉴 예시: {esc(", ".join(f.menuExamples))}</div>')
                if getattr(f, 'placeDescription', None):
                    parts.append(f'<div style="margin-top:6px;color:#374151">{esc(f.placeDescription)}</div>')
                parts.append('</div>')
        else:
            parts.append('<div style="font-size:13px;color:#6b7280">식당 정보가 없습니다.</div>')
        parts.append('</div>')

        # accommodation
        parts.append('<div>')
        parts.append('<div style="font-weight:600;margin-bottom:6px">숙박</div>')
        if daily.accommodationDetails:
            for a in daily.accommodationDetails:
                parts.append('<div style="border:1px solid #eef2ff;padding:8px;border-radius:6px;background:#fff">')
                parts.append(f'<div style="font-weight:600">{esc(a.placeName)}</div>')
                if getattr(a, 'roomType', None):
                    parts.append(f'<div style="font-size:12px;color:#6b7280">객실: {esc(a.roomType)}</div>')
                if getattr(a, 'priceRange', None):
                    parts.append(f'<div style="font-size:12px;color:#6b7280">요금 범위: {esc(a.priceRange.min)} ~ {esc(a.priceRange.max)}원</div>')
                if getattr(a, 'pricePerPerson', None):
                    parts.append(f'<div style="font-size:12px;color:#6b7280">1인당: {esc(a.pricePerPerson.min)} ~ {esc(a.pricePerPerson.max)}원</div>')
                if getattr(a, 'placeDescription', None):
                    parts.append(f'<div style="margin-top:6px;color:#374151">{esc(a.placeDescription)}</div>')
                parts.append('</div>')
        else:
            parts.append('<div style="font-size:13px;color:#6b7280">숙박 정보가 없습니다.</div>')
        parts.append('</div>')

        parts.append('</section>')

    # trip summary
    parts.append('<section style="padding:12px;border-radius:6px;background:#fff;border:1px solid #e5e7eb">')
    parts.append('<h3 style="margin:0 0 6px 0;font-size:16px">여행 전체 요약</h3>')
    parts.append(f'<div style="font-size:13px;color:#374151">식비 합계: {esc(trip_summary.totalFoodCost)}원</div>')
    parts.append(f'<div style="font-size:13px;color:#374151">숙박 합계: {esc(trip_summary.totalAccommodationMin)} ~ {esc(trip_summary.totalAccommodationMax)}원</div>')
    parts.append(f'<div style="font-size:13px;color:#374151">1인당 예상: {esc(trip_summary.perPersonCost.min)} ~ {esc(trip_summary.perPersonCost.max)}원</div>')
    parts.append('</section>')

    parts.append('</div>')
    return '\n'.join(parts)



# --- AI 호출 헬퍼 함수 (기존 로직 재사용) ---

def _estimate_food_price(block: PlaceBlockVO, headcount: int) -> dict:
    """Estimate food price using AI. Returns dict with at least 'estimatedPrice' and optional 'menuExamples'.
    Uses retries and a strict JSON prompt to improve reliability.
    """
    if not gemini_model:
        return {"estimatedPrice": 15000, "menuExamples": []}

    # richer structured prompt asking for price range and examples
    prompt = f"""
    아래 정보는 식당에 대한 기본 메타데이터입니다:
    이름: {block.placeName}
    주소: {block.placeAddress}
    평점: {block.placeRating}

    이 식당에서 1인당 평균 식사 비용을 추정해 주세요. 가능한 경우 가격 범위(min, max)와 대표 메뉴 예시도 함께 제공하십시오.
    반드시 JSON만 출력하세요. 예시 구조:
    {{
      "estimatedPrice": 15000,              # 1인당 중간값(정수)
      "priceRange": [12000, 20000],        # [min, max]
      "menuExamples": ["메뉴1", "메뉴2"],
      "confidence": "low|medium|high"
    }}
    """

    last_err = None
    for attempt in range(3):
        try:
            response = gemini_model.generate_content(prompt)
            parsed = _parse_json_response(response.text)
            if isinstance(parsed, dict) and parsed.get("estimatedPrice") is not None:
                # normalize fields
                if "menuExamples" not in parsed:
                    parsed.setdefault("menuExamples", [])
                if "priceRange" not in parsed and parsed.get("estimatedPrice") is not None:
                    p = parsed.get("estimatedPrice")
                    parsed["priceRange"] = [int(p * 0.8), int(p * 1.2)]
                return parsed
        except Exception as e:
            last_err = e
            logger.warning(f"Food price attempt {attempt+1} failed for {block.placeName}: {e}")
            time.sleep(0.6 * (attempt + 1))

    logger.error(f"Food prediction failed for {block.placeName}: {last_err}")
    return {"estimatedPrice": 15000, "priceRange": [12000, 18000], "menuExamples": []}

def _estimate_accommodation_price(block: PlaceBlockVO, headcount: int) -> dict:
    """Estimate accommodation pricing and room types via AI.
    Returns dict matching expected structure: recommendedRoomTypeForHeadcount, roomTypes (list of {type, priceRange}).
    Uses retries and fallback values on failure.
    """
    if not gemini_model:
        return {}

    prompt = f"""
    아래는 숙소의 기본 정보입니다:
    이름: {block.placeName}
    주소: {block.placeAddress}
    평점: {block.placeRating}
    여행 인원: {headcount}

    이 정보를 바탕으로 해당 숙소에서 {headcount}명에게 적합한 객실 유형과 각 객실 유형의 1박당 가격 범위를 (min, max)으로 추정해 주세요.
    반드시 JSON만 출력하세요. 예시 구조:
    {{
      "recommendedRoomTypeForHeadcount": "더블룸",
      "roomTypes": [
         {{"type": "싱글룸", "priceRange": [50000, 70000]}},
         {{"type": "더블룸", "priceRange": [80000, 120000]}}
      ],
      "confidence": "low|medium|high"
    }}
    """

    last_err = None
    for attempt in range(3):
        try:
            response = gemini_model.generate_content(prompt)
            parsed = _parse_json_response(response.text)
            if isinstance(parsed, dict) and parsed.get("roomTypes"):
                return parsed
        except Exception as e:
            last_err = e
            logger.warning(f"Accommodation attempt {attempt+1} failed for {block.placeName}: {e}")
            time.sleep(0.6 * (attempt + 1))

    logger.error(f"Accommodation prediction failed for {block.placeName}: {last_err}")
    # Fallback: provide a generic roomTypes suggestion
    return {
        "recommendedRoomTypeForHeadcount": "스탠다드룸",
        "roomTypes": [
            {"type": "스탠다드룸", "priceRange": [50000, 100000]},
        ]
    }

def _parse_json_response(text: str) -> dict:
    try:
        text = text.strip()
        if text.startswith("```json"): text = text[7:]
        if text.startswith("```"): text = text[3:]
        if text.endswith("```"): text = text[:-3]
        return json.loads(text.strip())
    except:
        return {}


def _summarize_place(block: PlaceBlockVO) -> str:
    """Generate a short (1-2 sentence) human-readable description for a place using Gemini.
    Returns an empty string on failure.
    """
    if not gemini_model:
        return ""

    try:
        prompt = f"""
        장소명: {block.placeName}\n
        장소에 대해 사용자에게 보여줄 1-2문장 요약을 생성해줘.\n
        JSON만 출력: {{"summary": "요약문"}}
        """
        resp = gemini_model.generate_content(prompt)
        parsed = _parse_json_response(resp.text)
        return parsed.get("summary", "") if isinstance(parsed, dict) else ""
    except Exception as e:
        logger.error(f"Place summary generation failed for {block.placeName}: {e}")
        return ""